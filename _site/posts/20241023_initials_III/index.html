<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.39">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Guido Huyberechts">
<meta name="dcterms.date" content="2024-10-26">
<meta name="description" content="Looking into real life initials">

<title>When initials collide (III) – GHUY’S SILVA RERUM</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-e26003cea8cd680ca0c55a263523d882.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-dark-d166b450ba5a8e9f7a0ab969bf6592c1.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-4474e186233a43fdd296253c1faf3772.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../site_libs/bootstrap/bootstrap-dark-af08959c45e7d8282662167e59d56a4a.min.css" rel="prefetch" append-hash="true" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../../styles.scss">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">GHUY’S SILVA RERUM</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../stories.html"> 
<span class="menu-text">Stories</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../publications.html"> 
<span class="menu-text">Publications</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">When initials collide (III)</h1>
<p class="subtitle lead">A reality check</p>
  <div class="quarto-categories">
    <div class="quarto-category">statistics</div>
    <div class="quarto-category">fun</div>
    <div class="quarto-category">EN</div>
  </div>
  </div>

<div>
  <div class="description">
    Looking into real life initials
  </div>
</div>


<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Guido Huyberechts </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">October 26, 2024</p>
    </div>
  </div>
  
    <div>
    <div class="quarto-title-meta-heading">Modified</div>
    <div class="quarto-title-meta-contents">
      <p class="date-modified">January 24, 2025</p>
    </div>
  </div>
    
  </div>
  


</header>


<div class="cell">
<style type="text/css">
p {
text-align: justify
}
figcaption {
  margin: auto;
  text-align: center;
}
</style>
</div>
<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">Introduction</h2>
<p>My oh my, the third post in a series. This rabbit hole is much deeper than we thought, and this for <em>a rather trivial anecdote</em>.</p>
<p>In the first post in this series we picked up the question and modified the code by Antoine Soetewey (“AS”) from Stats and R<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> a bit to allow the probability of the first letters of a first and a family name to deviate from 1/26.</p>
<p>In the second post we calculated the probability functions for first letters in first and family names in (a large part) of the Belgian population, based on data from Statbel<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>.</p>
<p>And now, based on the same data, we will calculate the probabilities of two-letter initials based on these probabilities and compare simulations to these.</p>
</section>
<section id="generating-two-letter-initials" class="level2">
<h2 class="anchored" data-anchor-id="generating-two-letter-initials">Generating two-letter initials</h2>
<p>Remember that in the first post we randomly selected the starting letter of the first name from the list of 26 letters. And next randomly selected the starting letter from the family name from the list of the same (duh) 26 letters. Obviously.</p>
<p>Let’s prepare for a small change that may save us some computational work when dealing later with larger numbers of simulations.</p>
<p>We directly take into account the fact that the number of two-letter combinations is in fact not <em>that</em> large, actually 676. And we can use the same approach as before, but now for directly selection the combination of two letters with a single random draw.</p>
<p>First have a look into all possibilities. As in the previous post we could plot the fraction or probability vs the combination of two letters. As the number of different two-letter initials is nevertheless large enough to make it difficult to display as a barchart, we “stretch out” the x-axis and curve it into a circle, glue both ends togetehr at the top and make a lollipop graph on a polar coordinates plot.</p>
<p>In <a href="#fig-6" class="quarto-xref">Figure&nbsp;1</a> the axis starts at the top with AA, AB, AC, …, moving clockwise to end with ZZ back on top. The data are drawn from this circle inwards to the center of the plot, the lollipop bubble showing the actual frequency.</p>
<p>The green dashed circle corresponds to the probability of 0.1479 % (i.e.&nbsp;the equal probabilities for all letters case). The grey dotted circles refer to 0.5, 1.0, 1.5 and 2.0 % probabilities. Hence every lollipop ending up in the bull’s eye has certainly a higher probability than 2.0 %.</p>
<div class="cell" data-layout-align="center">
<div class="cell-output-display">
<div id="fig-6" class="quarto-float quarto-figure quarto-figure-center anchored" data-fig-align="center" data-fig-pos="!h">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-6-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="img/chunk15.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:100.0%" data-fig-pos="!h">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-6-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;1: Frequency of two-letter initials
</figcaption>
</figure>
</div>
</div>
</div>
<p>So a whopping 2.14 % of our population has as initials MV. In contrast to, for example, AS (0.64 %) and GH (0.16 %). But truly rare are the combinations QQ (1.93 ppm), ZX (1.13 ppm), XX (0.32 ppm), QX (0.29 ppm) and UX (0.23 ppm). Or a factor of about 90 000 difference between the most and the least frequent letter combination. This alsp makes the plot a bit crowded and hard to read. If we make a heatmap out of it, color coding the frequency in a matrix of letters, we face the same problem, unless we transform the frequency coding somewhat.</p>
<p>In <a href="#fig-7" class="quarto-xref">Figure&nbsp;2</a> we have taken the log<sub>10</sub> of the ratio of the frequency to the smallest frequency observed.</p>
<p>It becomes clear that first names and family names with Q, U, X are not that common, surprise. However, also I, Y and Z are quite dark coloured on the family name side and hence are not that common. The brightest intersection can be found at MV and MD, confirming what we already knew. For the less common combinations we now also have a better visualisation of the relative frequencies.</p>
<div class="cell" data-layout-align="center">
<div class="cell-output-display">
<div id="fig-7" class="quarto-float quarto-figure quarto-figure-center anchored" data-fig-align="center" data-fig-pos="!h">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-7-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="img/chunk16.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:80.0%" data-fig-pos="!h">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-7-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;2: Frequency of two-letter initials (as log10(freq/minimum)
</figcaption>
</figure>
</div>
</div>
</div>
<p>So far we didn’t perform a simulation yet, did we? Nope, but it is coming. However, let us have look at the probability distribution in more detail first.</p>
<p>In a simulation we will first do exactly the same as in the case with equal probabilities for the letters: eight persons, 1000 redraws and 100 repeats.</p>
<p>Hmm. So we plan again to do 8 x 1000 x 100 = 800000 draws of two letters. We know that we have 676 combinations or bins of all possible letter combinations. So for equal letter probabilities we had on average about 1183 M&amp;M’s in each bin (because of the equal probabilities: 800000/676).</p>
<p>Now we are facing a situation where these probabilities are not equal anymore. We have way more chance to draw MV (namely 17120 M&amp;M’s in the MV bin) than AS (5120 M&amp;M’s) and certainly more than UX (0.18 M&amp;M, so actually none).</p>
<p>This means that for UX with a probability of 2.3 10<sup>-7</sup> we find 1 such combination in 4.3 million people. Or about two or three people in the whole population of Belgium of roughly 12 million, and we only plan to 800000 draws… Chances are low that in our simulation we will encounter someone from the Xu, XHrouet, Xhonneux, Xia, … families.</p>
</section>
<section id="the-simulation" class="level2">
<h2 class="anchored" data-anchor-id="the-simulation">The simulation</h2>
<section id="comparing-the-methodologies" class="level3">
<h3 class="anchored" data-anchor-id="comparing-the-methodologies">Comparing the methodologies</h3>
<p>Let us anyhow perform the simulation as planned, so that we can compare with the equal probability case.</p>
<p>We use essentially the same code as in the previous posts, except for the fact that we use the probability distribution function for the 676 initials and a single random number draw.</p>
<p>We now compare the number of persons ending up in the bin corresponding their initials, as obtained in our simulation <em>vs</em> the number that can be calculated from the probability distribution. For the time being, we do so for one experiment only, so drawing 1000 teams of 8 persons. For comparison, each bin would hold 11.83 persons in case of equal probability letters).</p>
<div class="cell" data-layout-align="center">
<div class="cell-output-display">
<div id="fig-17a" class="quarto-float quarto-figure quarto-figure-center anchored" data-fig-align="center" data-fig-pos="!h">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-17a-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="img/chunk17.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:80.0%" data-fig-pos="!h">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-17a-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;3: Validation plot (on a single experiment)
</figcaption>
</figure>
</div>
</div>
</div>
<p>In <a href="#fig-17a" class="quarto-xref">Figure&nbsp;3</a> we plotted a sort of “validation plot”. If the number in each bin would be exacly the same when counted during the simulation and when calculated from the probability distribution function one would have all data point on the green diagonal (with intercept equal to zero, and a unity slope).</p>
<p>While all point gravitate around this line as expected, the graph also shows the distribution of the initial. A few with high probability and quite a lot lumped in the lower left corner.</p>
<p>Fitting a straight line through all data points yield an intercept of -0.2424012 and a slope of 1.0204829. Both in apparently reasonable agreement with our expectations.</p>
<p>It is tempting to attribute the deviations to the random nature of our simulations. This is the case, but also have a more detailed look into the dot cloud in the lower left corner (the black rectangle in the insert in <a href="#fig-18a" class="quarto-xref">Figure&nbsp;4</a>).</p>
<div class="cell" data-layout-align="center">
<div class="cell-output-display">
<div id="fig-18a" class="quarto-float quarto-figure quarto-figure-center anchored" data-fig-align="center" data-fig-pos="!h">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-18a-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="img/chunk18a.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:80.0%" data-fig-pos="!h">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-18a-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;4: Validation plot detail (a single experiment)
</figcaption>
</figure>
</div>
</div>
</div>
<p>If we calculate the number of persons in a specific bin from the probability we end up with decimal numbers. We feel more comfortable with counting the persons from the simulation, then we have at least complete persons in each bin …</p>
<p>This of course has some influence on the fitting results, but especially notice something else. If we look at the simulation bins with, say, five persons added, we notice that they cover quite a range of bins (roughly from two to eleven) on the probability side. So if we would expect two persons based on probability, we can get five. But also if we would expect to encounter eleven persons. Quite a lot of other combinations exist of course, due to the random nature. That is not the problem. But how can we express the accuracy of the simulation and does this, well quite large deviations change with the number of expeced people (or the probability distribution)?</p>
<p>Let’s plot the differences between the number of persons simulated and expected (based on probability theory) <em>vs</em> the expected number.</p>
<div class="cell" data-layout-align="center">
<div class="cell-output-display">
<div id="fig-19a" class="quarto-float quarto-figure quarto-figure-center anchored" data-fig-align="center" data-fig-pos="!h">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-19a-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="img/chunk19a.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:80.0%" data-fig-pos="!h">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-19a-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;5: Comparing differences between methodologies (single experiment)
</figcaption>
</figure>
</div>
</div>
</div>
<p>We see that for the higher expected number the relative difference (expressed as (number(simulation)-number(probability))/number(probability))) approaches zero, as expected when both numbers are equal. On the other hand for lower numbers, meaning a lower probability of occurence of the corresponding initials, that we see more deviation. Some, where the number of simulation equals zero, the relative difference becomes minus one, and in other cases the simulation apparently large overestimate the outcome. Well, when dealing with smaller numbers one or two extra of course make a large difference.</p>
<p>Is this due to the fact that we only show the results of one experiment, or is this indeed an example of wat we can name a rare event bias?</p>
</section>
<section id="exploring-the-full-experiment" class="level3">
<h3 class="anchored" data-anchor-id="exploring-the-full-experiment">Exploring the full experiment</h3>
<p>When we would plot the data for 100 experiments as in <a href="#fig-17a" class="quarto-xref">Figure&nbsp;3</a>, it would be a complete mess. Therefore we calculate the average number of persons in each bin over the 100 experiments, and at the same time we calculate the standard deviation as well.</p>
<p>We ran 100 experiments, so in fact we have a dataframe of 676 x 100 elements. Not that much, so we can store it directly. We could also use incremental calculation formula for mean and standard deviation if the number of experiments would become larger.</p>
<div class="cell" data-layout-align="center">
<div class="cell-output-display">
<div id="fig-20a" class="quarto-float quarto-figure quarto-figure-center anchored" data-fig-align="center" data-fig-pos="!h">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-20a-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="img/chunk20a.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:80.0%" data-fig-pos="!h">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-20a-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;6: Comparing differences between methodologies (100 simulations)
</figcaption>
</figure>
</div>
</div>
</div>
<p>Now comparing <a href="#fig-20a" class="quarto-xref">Figure&nbsp;6</a> (for the average of 100 experiments) to <a href="#fig-17a" class="quarto-xref">Figure&nbsp;3</a> (for a single experiment, well, it looks muuuch better. But how about the differences? As we calculated a mean for each bin, we can also calculate the standard deviations.</p>
</section>
<section id="the-problem-of-rare-events" class="level3">
<h3 class="anchored" data-anchor-id="the-problem-of-rare-events">The problem of rare events</h3>
<p>While the variance of a MC estimator provides an absolute measure of how widely distributed it is around its mean value, in most cases a relative measure of the relative accuracy of the MC estimator is more useful. Such a measure is provided by the coeficient of variation (cv) of a RV Z, which is deined as cv[Z] = stdev[Z] /E[Z], where as usual stdev[Z] = √ var[Z] is the standard deviation. More precisely, the cv gives the number of samples that are necessary on average to achieve a given accuracy. To apply this concept in our case, suppose Z = Qˆ N. Since var[Qˆ N] = var[f(X)]/N, we have cv[Qˆ N] = cvQ/ √ N, where (with some abuse of notation) we denoted cvQ = stdev[f]/Q. Therefore, if we want cv[Qˆ ] to be below a target value cvo, on average we will need N &gt; (cvQ/cvo) 2 . In particular, for an indicator function the above calculations yield cv[Qˆ ] = √ (1 − Q)/(NQ). We can now see the problem of rare event simulation in a more quantitative way: If Q ≪ 1, the number of samples needed on average to obtain a given value of cv is N ∼ 1/(Qcv2 o ). For example, if Q ∼ 10−6 and we want a cv of 0.1, we need N = 108 samples. In other words, the problem is that, if Q ≪ 1, the events that make I(y(x)) = 1 have a very low probability of occurring, and therefore, a large number of samples is needed even to observe one such event, and an even larger number of samples is needed to obtain a reliable estimate. As mentioned in Section 1, VRTs are a collection of methods aimed at overcoming (or at least alleviating) this problem. In the following, we will look in some detail at two of them, namely IS and the cross-entropy metho</p>


</section>
</section>


<div id="quarto-appendix" class="default"><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><h2 class="anchored quarto-appendix-heading">Footnotes</h2>

<ol>
<li id="fn1"><p>https://statsandr.com/<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>https://statbel.fgov.be/nl/themas/bevolking/namen-en-voornamen<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section><section class="quarto-appendix-contents" id="quarto-citation"><h2 class="anchored quarto-appendix-heading">Citation</h2><div><div class="quarto-appendix-secondary-label">BibTeX citation:</div><pre class="sourceCode code-with-copy quarto-appendix-bibtex"><code class="sourceCode bibtex">@online{huyberechts2024,
  author = {Huyberechts, Guido},
  title = {When Initials Collide {(III)}},
  date = {2024-10-26},
  langid = {en}
}
</code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre><div class="quarto-appendix-secondary-label">For attribution, please cite this work as:</div><div id="ref-huyberechts2024" class="csl-entry quarto-appendix-citeas" role="listitem">
Huyberechts, Guido. 2024. <span>“When Initials Collide (III).”</span>
October 26, 2024.
</div></div></section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
    const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
    const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
    let newTheme = '';
    if(darkModeDefault) {
      newTheme = isAlternate ? baseTheme : alternateTheme;
    } else {
      newTheme = isAlternate ? alternateTheme : baseTheme;
    }
    const changeGiscusTheme = () => {
      // From: https://github.com/giscus/giscus/issues/336
      const sendMessage = (message) => {
        const iframe = document.querySelector('iframe.giscus-frame');
        if (!iframe) return;
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
      }
      sendMessage({
        setConfig: {
          theme: newTheme
        }
      });
    }
    const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
    if (isGiscussLoaded) {
      changeGiscusTheme();
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  const darkModeDefault = false;
  let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
    toggleGiscusIfUsed(toAlternate, darkModeDefault);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>